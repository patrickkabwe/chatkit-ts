import {
  AsyncQueue,
  QueueCompleteSentinel,
  QueueEventWrapper,
  QueueItem,
  queueEventIterator,
  streamWidget
} from "./helpers";
import type { StoreItemType } from "./store";
import type {
  ThreadMetadata,
  ThreadStreamEvent,
  AssistantMessageContent,
  AssistantMessageItem,
  ThreadItem,
  UserMessageItem,
  UserMessageTagContent,
  ClientToolCallItem,
  HiddenContextItem,
  SDKHiddenContextItem,
  WidgetItem,
  WorkflowItem,
  TaskItem,
  Attachment,
  Annotation
} from "./types";
import type { WidgetRoot, Text as TextWidget } from "./widgets";
import type { AgentInputItem, StreamEvent } from "@openai/agents";


export interface RunResultStreaming {
  streamEvents(): AsyncIterable<StreamEvent>;
}

/**
 * Client tool call descriptor – returned from tools to indicate that the
 * client (front-end) should perform some action.
 */
export interface ClientToolCall {
  name: string;
  arguments: Record<string, unknown>;
}

/**
 * Very small subset of the Store interface required by AgentContext.
 * Only the parts that the agents helpers rely on are modeled here.
 */
export interface StoreLike<TContext> {
  generateThreadId(context: TContext): string;
  generateItemId(
    itemType: StoreItemType,
    thread: ThreadMetadata,
    context: TContext
  ): string;
  loadThreadItems(
    threadId: string,
    after: string | null,
    limit: number,
    order: "asc" | "desc",
    context: TContext
  ): Promise<{ data: ThreadItem[] }>;
  addThreadItem(
    threadId: string,
    item: ThreadItem,
    context: TContext
  ): Promise<void>;
}


async function* mergeAsyncIterables<A, B>(
  a: AsyncIterable<A>,
  b: AsyncIterable<B>
): AsyncGenerator<A | B, void, unknown> {
  const ai = a[Symbol.asyncIterator]();
  const bi = b[Symbol.asyncIterator]();
  let nextA: Promise<IteratorResult<A>> | null = ai.next();
  let nextB: Promise<IteratorResult<B>> | null = bi.next();

  while (nextA || nextB) {
    const candidates: Array<
      Promise<{ source: "a" | "b"; result: IteratorResult<A | B> }>
    > = [];

    if (nextA) {
      candidates.push(
        nextA.then(result => ({ source: "a" as const, result }))
      );
    }
    if (nextB) {
      candidates.push(
        nextB.then(result => ({ source: "b" as const, result }))
      );
    }

    if (candidates.length === 0) {
      break;
    }

    const { source, result } = await Promise.race(candidates);

    if (result.done) {
      if (source === "a") {
        nextA = null;
      } else {
        nextB = null;
      }
      continue;
    }

    if (source === "a") {
      nextA = ai.next();
    } else {
      nextB = bi.next();
    }

    yield result.value;
  }
}

export type TContext = unknown;

/**
 * AgentContext carries request-scoped state for an agent run, including
 * thread metadata, backing store, and a queue of stream events generated
 * by helper methods such as `streamWidget`.
 */
export class AgentContext<C = TContext> {
  thread: ThreadMetadata;
  store: StoreLike<C>;
  requestContext: C = {} as C;
  previousResponseId: string | null;
  clientToolCall: ClientToolCall | null;
  workflowItem: WorkflowItem | null;

  // Internal queue of ThreadStreamEvents generated by helpers.
  private _events = new AsyncQueue<QueueItem>();

  constructor(args: {
    thread: ThreadMetadata;
    store: StoreLike<C>;
    requestContext?: C;
    previousResponseId?: string | null;
    clientToolCall?: ClientToolCall | null;
    client_tool_call?: ClientToolCall | null;
    workflowItem?: WorkflowItem | null;
    workflow_item?: WorkflowItem | null;
  }) {
    this.thread = args.thread;
    this.store = args.store;
    const reqCtx = args.requestContext
    if (reqCtx !== undefined) {
      this.requestContext = reqCtx;
    }
    this.previousResponseId = args.previousResponseId ?? null;
    this.clientToolCall = args.clientToolCall ?? null;
    this.workflowItem = args.workflowItem ?? null;
  }

  generateId(type: StoreItemType, thread?: ThreadMetadata): string {
    if (type === "thread") {
      return this.store.generateThreadId(this.requestContext);
    }
    return this.store.generateItemId(
      type,
      thread ?? this.thread,
      this.requestContext
    );
  }

  /**
   * Stream a widget (or async generator of widgets) into this context,
   * enqueueing all resulting ThreadStreamEvents.
   */
  async streamWidget<T extends WidgetRoot>(
    widget: T | AsyncGenerator<T, void, unknown>,
    copyText: string | null = null
  ): Promise<void> {
    for await (const event of streamWidget(
      this.thread,
      widget,
      copyText,
      itemType =>
        this.store.generateItemId(
          itemType,
          this.thread,
          this.requestContext
        )
    )) {
      this._events.enqueue(event);
    }
  }

  /**
   * Manually enqueue a ThreadStreamEvent into this context.
   */
  async stream(event: ThreadStreamEvent): Promise<void> {
    this._events.enqueue(event);
  }

  /**
   * Mark the internal queue as complete – no further events will be added.
   */
  _complete(): void {
    this._events.enqueue(new QueueCompleteSentinel());
    this._events.complete();
  }

  /**
   * Internal helper used by `streamAgentResponse` to iterate over queued events.
   */
  _eventIterator(): AsyncIterable<QueueItem> {
    // Return the AsyncIterable itself so callers can use `for await...of`
    // without worrying about the underlying iterator implementation.
    return this._events;
  }
}

function isThreadStreamEventLike(event: StreamEvent): event is ThreadStreamEvent {
  return (
    typeof event?.type === "string" &&
    (event.type.startsWith("thread.") ||
      event.type === "progress_update" ||
      event.type === "client_effect" ||
      event.type === "stream_options")
  );
}

/**
 * Merge events from the streaming runner and the AgentContext helper queue.
 */
export async function* streamAgentResponse<C>(params: {
  context: AgentContext<C>;
  result: RunResultStreaming;
}): AsyncGenerator<ThreadStreamEvent, void, unknown> {
  const { context, result } = params;
  const merged = mergeAsyncIterables(
    result.streamEvents(),
    queueEventIterator(context._eventIterator())
  );

  try {
    for await (const wrapped of merged) {
      if (wrapped instanceof QueueEventWrapper) {
        const queueItem = wrapped.event;
        if (queueItem instanceof QueueCompleteSentinel) {
          continue;
        }
        // Queue events are already ThreadStreamEvents from helper methods
        yield queueItem as ThreadStreamEvent;
        continue;
      }

      const streamEvent = wrapped as StreamEvent;
      
      // Filter out internal SDK events that shouldn't be sent to the client
      if (streamEvent.type === "run_item_stream_event") {
        // Skip run_item_stream_event - it's internal to the SDK
        continue;
      }
      
      // Only raw_response_event should be processed from the stream; other
      // event types (including raw_model_stream_event) are skipped.
      if (streamEvent.type !== "raw_response_event") {
        // Ignore everything else that isn't a raw_response_event
        // This includes raw_model_stream_event and any other SDK internal events
        continue;
      }
      
      // For raw_response_event, we would normally convert it to ThreadStreamEvents here
      // However, the conversion logic is not yet implemented in TypeScript
      // For now, we skip it to avoid sending invalid events to the client
      // TODO: Implement raw_response_event conversion to ThreadStreamEvents
      continue;
    }
  } finally {
    context._complete();

    // Drain remaining queued events after marking completion.
    for await (const item of context._eventIterator()) {
      if (item instanceof QueueCompleteSentinel) {
        continue;
      }
      yield item as ThreadStreamEvent;
    }
  }
}

/**
 * Accumulates text deltas from a stream of raw response events into a widget.
 */
export async function* accumulateText(
  events: AsyncIterable<StreamEvent>,
  baseWidget: TextWidget
): AsyncGenerator<TextWidget, void, unknown> {
  let text = "";
  // Start with the original widget.
  yield baseWidget;

  for await (const event of events) {
    if (
      event.type === "raw_response_event" &&
      event.data?.type === "response.output_text.delta"
    ) {
      text += String(event.data.delta ?? "");
      yield {
        ...baseWidget,
        value: text
      };
    }
  }

  // Final widget with streaming turned off.
  yield {
    ...baseWidget,
    value: text,
    streaming: false
  };
}

/**
 * Shapes representing the OpenAI Agents "easy input" message format.
 */
export type AgentInputContentPart =
  | {
      type: "input_text";
      text: string;
    }
  | {
      type: "output_text";
      text: string;
      annotations?: Array<{
        source: Annotation["source"];
        index: Annotation["index"];
      }>;
    }
  | {
      type: "input_image";
      image_url: { url: string };
    }
  | {
      type: "input_file";
      file_id?: string;
      file_url?: string;
    };


function flattenAgentInput(
  value: AgentInputItem | AgentInputItem[] | null | undefined
): AgentInputItem[] {
  if (!value) return [];
  return Array.isArray(value) ? value : [value];
}

/**
 * ThreadItemConverter converts internal thread items into the Agents SDK
 * "easy input" format, with stub methods for app-specific extensions and
 * loud failures for unsupported item types (attachments, mentions, hidden
 * context, tasks, workflows).
 */
export class ThreadItemConverter {
  async attachmentToMessageContent(
    _attachment: Attachment
  ): Promise<AgentInputContentPart> {
    throw new Error(
      "Converter.attachmentToMessageContent must be implemented to handle attachments on user messages."
    );
  }

  async tagToMessageContent(_tag: unknown): Promise<AgentInputContentPart> {
    throw new Error(
      "Converter.tagToMessageContent must be implemented to handle @-mentions or tags on user messages."
    );
  }

  async hiddenContextToInput(
    _item: HiddenContextItem | SDKHiddenContextItem
  ): Promise<AgentInputItem | AgentInputItem[] | null> {
    throw new Error(
      "HiddenContextItems require Converter.hiddenContextToInput to be implemented."
    );
  }

  async taskToInput(
    _item: TaskItem
  ): Promise<AgentInputItem | AgentInputItem[] | null> {
    throw new Error(
      "TaskItems require Converter.taskToInput to be implemented."
    );
  }

  async workflowToInput(
    _item: WorkflowItem
  ): Promise<AgentInputItem | AgentInputItem[] | null> {
    throw new Error(
      "WorkflowItems require Converter.workflowToInput to be implemented."
    );
  }

  async widgetToInput(
    item: WidgetItem
  ): Promise<AgentInputItem | AgentInputItem[] | null> {
    return {
      type: "message",
      role: "user",
      content: [
        {
          type: "input_text",
          text:
            `The following graphical UI widget (id: ${item.id}) was displayed to the user:` +
            JSON.stringify(item.widget)
        }
      ]
    };
  }

  protected formatAssistantContent(
    content: AssistantMessageContent[]
  ): AgentInputContentPart[] {
    return (content ?? []).map(part => ({
      type: "output_text",
      text: part.text,
      annotations: (part.annotations ?? []).map(a => ({
        source: a.source,
        index: a.index
      }))
    }));
  }

  protected async assistantMessageToInput(
    item: AssistantMessageItem
  ): Promise<AgentInputItem | AgentInputItem[] | null> {
    return {
      type: "message",
      role: "assistant",
      content: this.formatAssistantContent(item.content ?? [])
    };
  }

  protected async buildUserMessageContentParts(
    item: UserMessageItem
  ): Promise<AgentInputContentPart[]> {
    const textParts: string[] = [];
    const tagParts: AgentInputContentPart[] = [];

    for (const part of item.content ?? []) {
      if (part.type === "input_tag") {
        tagParts.push(await this.tagToMessageContent(part as UserMessageTagContent));
      } else {
        textParts.push(part.text ?? "");
      }
    }

    const messageText = textParts.join("");

    const parts: AgentInputContentPart[] = [
      {
        type: "input_text",
        text: messageText
      }
    ];

    for (const attachment of item.attachments ?? []) {
      parts.push(await this.attachmentToMessageContent(attachment));
    }

    return [...parts, ...tagParts];
  }

  protected async userMessageToInput(
    item: UserMessageItem,
    isLastMessage: boolean
  ): Promise<AgentInputItem | AgentInputItem[] | null> {
    const baseMessage: AgentInputItem = {
      type: "message",
      role: "user",
      content: await this.buildUserMessageContentParts(item)
    } as AgentInputItem;

    const contextItems: AgentInputItem[] = [];
    if (item.quoted_text && isLastMessage) {
      contextItems.push({
        type: "message",
        role: "user",
        content: [
          {
            type: "input_text",
            text: `The user is referring to this in particular:\n${item.quoted_text}`
          }
        ]
      });
    }

    return [baseMessage, ...contextItems];
  }

  protected async clientToolCallToInput(
    item: ClientToolCallItem
  ): Promise<AgentInputItem | AgentInputItem[] | null> {
    if (item.status === "pending") {
      return null;
    }

    const calls: AgentInputItem[] = [
      {
        type: "function_call",
        call_id: item.call_id,
        name: item.name,
        arguments: JSON.stringify(item.arguments ?? {})
      }
    ];

    if (item.output !== undefined) {
      calls.push({
        type: "function_call_output",
        call_id: item.call_id,
        output: JSON.stringify(item.output)
      });
    }

    return calls;
  }

  protected async widgetItemToInput(
    item: WidgetItem
  ): Promise<AgentInputItem | AgentInputItem[] | null> {
    return this.widgetToInput(item);
  }

  protected async threadItemToInputItem(
    item: ThreadItem,
    isLastMessage: boolean
  ): Promise<AgentInputItem[]> {
    switch (item.type) {
      case "user_message":
        return flattenAgentInput(
          await this.userMessageToInput(item, isLastMessage)
        );
      case "assistant_message":
        return flattenAgentInput(
          await this.assistantMessageToInput(item)
        );
      case "client_tool_call":
        return flattenAgentInput(
          await this.clientToolCallToInput(item)
        );
      case "hidden_context":
      case "sdk_hidden_context":
        return flattenAgentInput(
          await this.hiddenContextToInput(item)
        );
      case "task":
        return flattenAgentInput(await this.taskToInput(item));
      case "workflow":
        return flattenAgentInput(await this.workflowToInput(item));
      case "widget":
        return flattenAgentInput(await this.widgetItemToInput(item));
      default:
        return [];
    }
  }

  protected async looseRoleToInput(
    item: unknown
  ): Promise<AgentInputItem[] | null> {
    if (
      item &&
      typeof item === "object" &&
      "role" in item &&
      typeof (item as { role: unknown }).role === "string" &&
      "text" in item &&
      typeof (item as { text: unknown }).text === "string"
    ) {
      const roleItem = item as { role: string; text: string };
      const role = roleItem.role;
      const contentType =
        role === "assistant" ? ("output_text" as const) : ("input_text" as const);

      return [
        {
          type: "message",
          role,
          content: [
            {
              type: contentType,
              text: roleItem.text
            }
          ]
        }
      ];
    }

    return null;
  }

  /**
   * Converts simple “chat-like” items into the Easy Input API shape expected
   * by the OpenAI Agents SDK. This is intentionally narrower but preserves
   * the same external contract for user and assistant messages.
   */
  async toAgentInput(
    threadItems: ThreadItem[] | ThreadItem | unknown
  ): Promise<AgentInputItem[]> {
    const itemsArray = Array.isArray(threadItems)
      ? threadItems.slice()
      : [threadItems];
    const output: AgentInputItem[] = [];

    for (const item of itemsArray) {
      const looseConversion = await this.looseRoleToInput(item);
      if (looseConversion) {
        output.push(...looseConversion);
        continue;
      }

      const converted = await this.threadItemToInputItem(
        item as ThreadItem,
        item === itemsArray[itemsArray.length - 1]
      );

      if (converted.length === 0) {
        // Preserve unknown shapes but keep the pipeline streaming.
        output.push(item as AgentInputItem);
        continue;
      }

      output.push(...converted);
    }

    return output;
  }
}

const DEFAULT_CONVERTER = new ThreadItemConverter();

export function simpleToAgentInput(
  threadItems: ThreadItem[] | ThreadItem | unknown
): Promise<AgentInputItem[]> {
  return DEFAULT_CONVERTER.toAgentInput(threadItems);
}

type RunStreamedFn<C> = (
  agent: unknown,
  input: AgentInputItem[],
  options: { context: AgentContext<C> }
) => RunResultStreaming | Promise<RunResultStreaming>;

type RunnerLike<C = unknown> =
  | RunStreamedFn<C>
  | {
      runStreamed?: RunStreamedFn<C>;
    };

export function resolveRunner<C>(runner: RunnerLike<C>): RunStreamedFn<C> {
  if (typeof runner === "function") {
    return runner;
  }

  const candidate =
    (runner as { runStreamed?: RunStreamedFn<C> }).runStreamed;

  if (typeof candidate !== "function") {
    throw new Error(
      "Runner must expose runStreamed(...) to match the Runner.run_streamed API."
    );
  }

  return (agent, input, options) => candidate.call(runner, agent, input, options);
}

/**
 * Helper that runs an agent with a streaming runner and yields the resulting
 * thread stream events.
 */
export async function* respondWithAgent<C>(params: {
  agent: unknown;
  runner: RunnerLike<C>;
  store: StoreLike<C>;
  thread: ThreadMetadata;
  input: ThreadItem | ThreadItem[] | null;
  context: C;
  converter?: ThreadItemConverter;
}): AsyncGenerator<ThreadStreamEvent, void, unknown> {
  const {
    agent,
    runner,
    store,
    thread,
    input,
    context,
    converter = DEFAULT_CONVERTER
  } = params;

  const c = new AgentContext<C>({
    thread,
    store,
    requestContext: context
  });

  const agentInput = input ? await converter.toAgentInput(input) : [];
  const runStreamed = resolveRunner(runner);
  const result = await runStreamed(agent, agentInput, { context: c });

  for await (const event of streamAgentResponse({ context: c, result })) {
    yield event;
  }
}
